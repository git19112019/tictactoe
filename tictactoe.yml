tic_tac_toe_game:
  description: "Complete Tic Tac Toe game design with pseudocode, implementation, flowchart, and JSON state."

  # üß† Pseudocode Logic
  pseudocode:
    description: "Step-by-step logic for Tic Tac Toe, including win, draw, and restart."
    steps:
      - Initialize game:
          actions:
            - Create a 3x3 empty board
            - Set current player to 'X'
            - Set game_over to False
            - Initialize move_history list
      - Main game loop:
          actions:
            - Display the board
            - Prompt player for action:
                - Move
                - Restart
                - Exit
            - If move:
                - Validate
                - If valid:
                    - Apply move
                    - Add to move_history
                    - Check win
                    - Check draw
                    - If not over ‚Üí switch player
                - If invalid: retry
            - If restart:
                - Reset board and variables
            - If exit:
                - Terminate game
      - End game:
          actions:
            - Announce winner or draw
            - Offer restart or exit

  # üêç Python Code Implementation
  python_code:
    description: "Python implementation of Tic Tac Toe."
    snippet: |
      class TicTacToe:
          SIZE = 3

          def __init__(self):
              self.board = [[' ' for _ in range(self.SIZE)] for _ in range(self.SIZE)]
              self.current_player = 'X'
              self.game_over = False
              self.winner = None
              self.move_history = []

          def display_board(self):
              for row in self.board:
                  print(' | '.join(row))
                  print('-' * 5)

          def is_valid_move(self, x, y):
              return 0 <= x < self.SIZE and 0 <= y < self.SIZE and self.board[x][y] == ' '

          def make_move(self, x, y):
              if self.is_valid_move(x, y):
                  self.board[x][y] = self.current_player
                  self.move_history.append((x, y))
                  return True
              return False

          def switch_player(self):
              self.current_player = 'O' if self.current_player == 'X' else 'X'

          def check_win(self):
              # Check rows, columns, and diagonals
              for i in range(self.SIZE):
                  if all(self.board[i][j] == self.current_player for j in range(self.SIZE)) or \
                     all(self.board[j][i] == self.current_player for j in range(self.SIZE)):
                      self.winner = self.current_player
                      self.game_over = True
                      return True

              if all(self.board[i][i] == self.current_player for i in range(self.SIZE)) or \
                 all(self.board[i][self.SIZE - i - 1] == self.current_player for i in range(self.SIZE)):
                  self.winner = self.current_player
                  self.game_over = True
                  return True
              return False

          def is_draw(self):
              if all(cell != ' ' for row in self.board for cell in row):
                  self.game_over = True
                  return True
              return False

          def restart_game(self):
              self.__init__()
              print("Game restarted.")

          def play(self):
              while not self.game_over:
                  self.display_board()
                  print(f"Player {self.current_player}'s turn.")
                  try:
                      x, y = map(int, input("Enter row and column (e.g., 1 2): ").split())
                  except ValueError:
                      print("Invalid input.")
                      continue

                  if self.make_move(x, y):
                      if self.check_win():
                          self.display_board()
                          print(f"Player {self.current_player} wins!")
                          break
                      elif self.is_draw():
                          self.display_board()
                          print("It's a draw!")
                          break
                      self.switch_player()
                  else:
                      print("Invalid move.")

              if input("Play again? (y/n): ").lower().startswith('y'):
                  self.restart_game()
                  self.play()

      if __name__ == "__main__":
          game = TicTacToe()
          game.play()

  # üîÅ Flowchart (Mermaid Syntax)
  flowchart:
    description: "Game flow logic for Tic Tac Toe."
    diagram: |
      graph TD
        Start[Start Game] --> Init[Initialize Game]
        Init --> Loop[Main Game Loop]
        Loop --> Board[Display Board]
        Board --> Action{Choose Action}
        Action -- Move --> Validate[Validate Move]
        Validate -- Invalid --> Loop
        Validate -- Valid --> ApplyMove[Apply Move]
        ApplyMove --> CheckWin[Check Win]
        CheckWin -- Yes --> EndWin[Declare Winner]
        CheckWin -- No --> CheckDraw[Check Draw]
        CheckDraw -- Yes --> EndDraw[Declare Draw]
        CheckDraw -- No --> Switch[Switch Player] --> Loop
        Action -- Restart --> RestartGame[Restart Game] --> Loop
        EndWin --> End[Game Over]
        EndDraw --> End

  # üßæ Example JSON Game State
  json_example:
    description: "Example serialized game state after a few moves."
    state: |
      {
        "board": [
          ["X", "O", " "],
          [" ", "X", " "],
          ["O", " ", "X"]
        ],
        "current_player": "O",
        "game_over": false,
        "winner": null,
        "move_history": [[0,0], [0,1], [1,1], [2,0], [2,2]],
      }
